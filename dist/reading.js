'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = traverse;
exports.read = read;

var _fileReader = require('./file-reader');

var _promise_fs = require('./promise_fs');

var fs = _interopRequireWildcard(_promise_fs);

var _scanning = require('./scanning');

var _util = require('./util');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function* traverse(node) {
  yield node;
  for (let child of node.children) {
    yield* traverse(child);
  }
}

class StringCids {
  constructor() {
    this.map = new Map();
  }

  // noinspection JSUnusedGlobalSymbols
  get(str) {
    let cid = this.map.get(str);
    if (cid === undefined) {
      cid = (0, _util.newCid)();
      this.map.set(str, cid);
    }
    return cid;
  }
}

const DirContentCids = new StringCids();
const LinkContentCids = new StringCids();

async function dirContent(nodes) {
  let data = '';
  for (let node of nodes) {
    let { path, cid } = node;
    data += (0, _util.padString)((await cid) + '', 20) + ' ' + path.name + '\n';
  }
  return data;
}

async function nodeContent(node, children, reader) {
  switch (node.type) {
    case _scanning.FileType.File:
      return reader.add(node);
    case _scanning.FileType.Directory:
      return DirContentCids.get((await dirContent(children)));
    case _scanning.FileType.Symlink:
      return LinkContentCids.get((await fs.readlink(node.path.get())));
    default:
      // For types other than file, directory or symlink, just use the cid
      // attached to the file type.
      return node.type.cid;
  }
}

function start(node, reader) {
  let { path, type, size } = node;
  let children = node.children.map(node => start(node, reader));
  let cid = nodeContent(node, children, reader);
  return { path, size, children, type, cid };
}

async function finish(node) {
  let { path, type, size } = node;
  let children = await Promise.all(node.children.map(finish));
  let cid = await node.cid;
  return { path, size, type, cid, children };
}

async function read(nodes) {
  let reader = new _fileReader.FileReader();
  let started = nodes.map(node => start(node, reader));
  await reader.run();
  return await Promise.all(started.map(finish));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWFkaW5nLmpzIl0sIm5hbWVzIjpbInRyYXZlcnNlIiwicmVhZCIsImZzIiwibm9kZSIsImNoaWxkIiwiY2hpbGRyZW4iLCJTdHJpbmdDaWRzIiwibWFwIiwiTWFwIiwiZ2V0Iiwic3RyIiwiY2lkIiwidW5kZWZpbmVkIiwic2V0IiwiRGlyQ29udGVudENpZHMiLCJMaW5rQ29udGVudENpZHMiLCJkaXJDb250ZW50Iiwibm9kZXMiLCJkYXRhIiwicGF0aCIsIm5hbWUiLCJub2RlQ29udGVudCIsInJlYWRlciIsInR5cGUiLCJGaWxlIiwiYWRkIiwiRGlyZWN0b3J5IiwiU3ltbGluayIsInJlYWRsaW5rIiwic3RhcnQiLCJzaXplIiwiZmluaXNoIiwiUHJvbWlzZSIsImFsbCIsInN0YXJ0ZWQiLCJydW4iXSwibWFwcGluZ3MiOiI7Ozs7O1FBYWlCQSxRLEdBQUFBLFE7UUFzRUtDLEksR0FBQUEsSTs7QUFoRnRCOztBQUNBOztJQUFZQyxFOztBQUNaOztBQUNBOzs7O0FBT08sVUFBVUYsUUFBVixDQUFtQkcsSUFBbkIsRUFBK0Q7QUFDcEUsUUFBTUEsSUFBTjtBQUNBLE9BQUssSUFBSUMsS0FBVCxJQUFrQkQsS0FBS0UsUUFBdkIsRUFBaUM7QUFDL0IsV0FBT0wsU0FBU0ksS0FBVCxDQUFQO0FBQ0Q7QUFDRjs7QUFPRCxNQUFNRSxVQUFOLENBQWlCO0FBQUE7QUFBQSxTQUNmQyxHQURlLEdBQ1QsSUFBSUMsR0FBSixFQURTO0FBQUE7O0FBRWY7QUFDQUMsTUFBSUMsR0FBSixFQUF5QjtBQUN2QixRQUFJQyxNQUFNLEtBQUtKLEdBQUwsQ0FBU0UsR0FBVCxDQUFhQyxHQUFiLENBQVY7QUFDQSxRQUFJQyxRQUFRQyxTQUFaLEVBQXVCO0FBQ3JCRCxZQUFNLG1CQUFOO0FBQ0EsV0FBS0osR0FBTCxDQUFTTSxHQUFULENBQWFILEdBQWIsRUFBa0JDLEdBQWxCO0FBQ0Q7QUFDRCxXQUFPQSxHQUFQO0FBQ0Q7QUFWYzs7QUFhakIsTUFBTUcsaUJBQWlCLElBQUlSLFVBQUosRUFBdkI7QUFDQSxNQUFNUyxrQkFBa0IsSUFBSVQsVUFBSixFQUF4Qjs7QUFFQSxlQUFlVSxVQUFmLENBQTBCQyxLQUExQixFQUErRTtBQUM3RSxNQUFJQyxPQUFPLEVBQVg7QUFDQSxPQUFLLElBQUlmLElBQVQsSUFBaUJjLEtBQWpCLEVBQXdCO0FBQ3RCLFFBQUksRUFBQ0UsSUFBRCxFQUFPUixHQUFQLEtBQWNSLElBQWxCO0FBQ0FlLFlBQVEscUJBQVUsQ0FBQyxNQUFNUCxHQUFQLElBQWMsRUFBeEIsRUFBNEIsRUFBNUIsSUFBa0MsR0FBbEMsR0FBd0NRLEtBQUtDLElBQTdDLEdBQW9ELElBQTVEO0FBQ0Q7QUFDRCxTQUFPRixJQUFQO0FBQ0Q7O0FBRUQsZUFBZUcsV0FBZixDQUNFbEIsSUFERixFQUVFRSxRQUZGLEVBR0VpQixNQUhGLEVBSW1CO0FBQ2pCLFVBQVFuQixLQUFLb0IsSUFBYjtBQUNFLFNBQUssbUJBQVNDLElBQWQ7QUFDRSxhQUFPRixPQUFPRyxHQUFQLENBQVd0QixJQUFYLENBQVA7QUFDRixTQUFLLG1CQUFTdUIsU0FBZDtBQUNFLGFBQU9aLGVBQWVMLEdBQWYsRUFBbUIsTUFBTU8sV0FBV1gsUUFBWCxDQUF6QixFQUFQO0FBQ0YsU0FBSyxtQkFBU3NCLE9BQWQ7QUFDRSxhQUFPWixnQkFBZ0JOLEdBQWhCLEVBQW9CLE1BQU1QLEdBQUcwQixRQUFILENBQVl6QixLQUFLZ0IsSUFBTCxDQUFVVixHQUFWLEVBQVosQ0FBMUIsRUFBUDtBQUNGO0FBQ0U7QUFDQTtBQUNBLGFBQU9OLEtBQUtvQixJQUFMLENBQVVaLEdBQWpCO0FBVko7QUFZRDs7QUFFRCxTQUFTa0IsS0FBVCxDQUFlMUIsSUFBZixFQUEyQm1CLE1BQTNCLEVBQTREO0FBQzFELE1BQUksRUFBQ0gsSUFBRCxFQUFPSSxJQUFQLEVBQWFPLElBQWIsS0FBcUIzQixJQUF6QjtBQUNBLE1BQUlFLFdBQVdGLEtBQUtFLFFBQUwsQ0FBY0UsR0FBZCxDQUFrQkosUUFBUTBCLE1BQU0xQixJQUFOLEVBQVltQixNQUFaLENBQTFCLENBQWY7QUFDQSxNQUFJWCxNQUFNVSxZQUFZbEIsSUFBWixFQUFrQkUsUUFBbEIsRUFBNEJpQixNQUE1QixDQUFWO0FBQ0EsU0FBTyxFQUFDSCxJQUFELEVBQU9XLElBQVAsRUFBYXpCLFFBQWIsRUFBdUJrQixJQUF2QixFQUE2QlosR0FBN0IsRUFBUDtBQUNEOztBQUVELGVBQWVvQixNQUFmLENBQXNCNUIsSUFBdEIsRUFBZ0U7QUFDOUQsTUFBSSxFQUFDZ0IsSUFBRCxFQUFPSSxJQUFQLEVBQWFPLElBQWIsS0FBcUIzQixJQUF6QjtBQUNBLE1BQUlFLFdBQVcsTUFBTTJCLFFBQVFDLEdBQVIsQ0FBWTlCLEtBQUtFLFFBQUwsQ0FBY0UsR0FBZCxDQUFrQndCLE1BQWxCLENBQVosQ0FBckI7QUFDQSxNQUFJcEIsTUFBTSxNQUFNUixLQUFLUSxHQUFyQjtBQUNBLFNBQU8sRUFBQ1EsSUFBRCxFQUFPVyxJQUFQLEVBQWFQLElBQWIsRUFBbUJaLEdBQW5CLEVBQXdCTixRQUF4QixFQUFQO0FBQ0Q7O0FBRU0sZUFBZUosSUFBZixDQUFvQmdCLEtBQXBCLEVBQTREO0FBQ2pFLE1BQUlLLFNBQVMsNEJBQWI7QUFDQSxNQUFJWSxVQUFVakIsTUFBTVYsR0FBTixDQUFVSixRQUFRMEIsTUFBTTFCLElBQU4sRUFBWW1CLE1BQVosQ0FBbEIsQ0FBZDtBQUNBLFFBQU1BLE9BQU9hLEdBQVAsRUFBTjtBQUNBLFNBQU8sTUFBTUgsUUFBUUMsR0FBUixDQUFZQyxRQUFRM0IsR0FBUixDQUFZd0IsTUFBWixDQUFaLENBQWI7QUFDRCIsImZpbGUiOiJyZWFkaW5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHR5cGUge05vZGV9IGZyb20gJy4vc2Nhbm5pbmcnO1xuaW1wb3J0IHtGaWxlUmVhZGVyfSBmcm9tICcuL2ZpbGUtcmVhZGVyJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJy4vcHJvbWlzZV9mcyc7XG5pbXBvcnQge0ZpbGVUeXBlfSBmcm9tICcuL3NjYW5uaW5nJztcbmltcG9ydCB7cGFkU3RyaW5nLCBuZXdDaWR9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGVOb2RlIGV4dGVuZHMgTm9kZSB7XG4gICtjaWQ6IG51bWJlcjtcbiAgK2NoaWxkcmVuOiAkUmVhZE9ubHlBcnJheTxDb21wbGV0ZU5vZGU+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHRyYXZlcnNlKG5vZGU6IENvbXBsZXRlTm9kZSk6IEl0ZXJhYmxlPENvbXBsZXRlTm9kZT4ge1xuICB5aWVsZCBub2RlO1xuICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgeWllbGQqIHRyYXZlcnNlKGNoaWxkKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUGVuZGluZ05vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgK2NpZDogUHJvbWlzZTxudW1iZXI+O1xuICArY2hpbGRyZW46ICRSZWFkT25seUFycmF5PFBlbmRpbmdOb2RlPjtcbn1cblxuY2xhc3MgU3RyaW5nQ2lkcyB7XG4gIG1hcCA9IG5ldyBNYXAoKTtcbiAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICBnZXQoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGxldCBjaWQgPSB0aGlzLm1hcC5nZXQoc3RyKTtcbiAgICBpZiAoY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNpZCA9IG5ld0NpZCgpO1xuICAgICAgdGhpcy5tYXAuc2V0KHN0ciwgY2lkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNpZDtcbiAgfVxufVxuXG5jb25zdCBEaXJDb250ZW50Q2lkcyA9IG5ldyBTdHJpbmdDaWRzKCk7XG5jb25zdCBMaW5rQ29udGVudENpZHMgPSBuZXcgU3RyaW5nQ2lkcygpO1xuXG5hc3luYyBmdW5jdGlvbiBkaXJDb250ZW50KG5vZGVzOiAkUmVhZE9ubHlBcnJheTxQZW5kaW5nTm9kZT4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBsZXQgZGF0YSA9ICcnO1xuICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB7XG4gICAgbGV0IHtwYXRoLCBjaWR9ID0gbm9kZTtcbiAgICBkYXRhICs9IHBhZFN0cmluZygoYXdhaXQgY2lkKSArICcnLCAyMCkgKyAnICcgKyBwYXRoLm5hbWUgKyAnXFxuJztcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbm9kZUNvbnRlbnQoXG4gIG5vZGU6IE5vZGUsXG4gIGNoaWxkcmVuOiBQZW5kaW5nTm9kZVtdLFxuICByZWFkZXI6IEZpbGVSZWFkZXIsXG4pOiBQcm9taXNlPG51bWJlcj4ge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgRmlsZVR5cGUuRmlsZTpcbiAgICAgIHJldHVybiByZWFkZXIuYWRkKG5vZGUpO1xuICAgIGNhc2UgRmlsZVR5cGUuRGlyZWN0b3J5OlxuICAgICAgcmV0dXJuIERpckNvbnRlbnRDaWRzLmdldChhd2FpdCBkaXJDb250ZW50KGNoaWxkcmVuKSk7XG4gICAgY2FzZSBGaWxlVHlwZS5TeW1saW5rOlxuICAgICAgcmV0dXJuIExpbmtDb250ZW50Q2lkcy5nZXQoYXdhaXQgZnMucmVhZGxpbmsobm9kZS5wYXRoLmdldCgpKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciB0eXBlcyBvdGhlciB0aGFuIGZpbGUsIGRpcmVjdG9yeSBvciBzeW1saW5rLCBqdXN0IHVzZSB0aGUgY2lkXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGUgZmlsZSB0eXBlLlxuICAgICAgcmV0dXJuIG5vZGUudHlwZS5jaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnQobm9kZTogTm9kZSwgcmVhZGVyOiBGaWxlUmVhZGVyKTogUGVuZGluZ05vZGUge1xuICBsZXQge3BhdGgsIHR5cGUsIHNpemV9ID0gbm9kZTtcbiAgbGV0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAobm9kZSA9PiBzdGFydChub2RlLCByZWFkZXIpKTtcbiAgbGV0IGNpZCA9IG5vZGVDb250ZW50KG5vZGUsIGNoaWxkcmVuLCByZWFkZXIpO1xuICByZXR1cm4ge3BhdGgsIHNpemUsIGNoaWxkcmVuLCB0eXBlLCBjaWR9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5pc2gobm9kZTogUGVuZGluZ05vZGUpOiBQcm9taXNlPENvbXBsZXRlTm9kZT4ge1xuICBsZXQge3BhdGgsIHR5cGUsIHNpemV9ID0gbm9kZTtcbiAgbGV0IGNoaWxkcmVuID0gYXdhaXQgUHJvbWlzZS5hbGwobm9kZS5jaGlsZHJlbi5tYXAoZmluaXNoKSk7XG4gIGxldCBjaWQgPSBhd2FpdCBub2RlLmNpZDtcbiAgcmV0dXJuIHtwYXRoLCBzaXplLCB0eXBlLCBjaWQsIGNoaWxkcmVufTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWQobm9kZXM6IE5vZGVbXSk6IFByb21pc2U8Q29tcGxldGVOb2RlW10+IHtcbiAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGxldCBzdGFydGVkID0gbm9kZXMubWFwKG5vZGUgPT4gc3RhcnQobm9kZSwgcmVhZGVyKSk7XG4gIGF3YWl0IHJlYWRlci5ydW4oKTtcbiAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHN0YXJ0ZWQubWFwKGZpbmlzaCkpO1xufVxuIl19