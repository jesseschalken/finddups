{"version":3,"sources":["../src/reading.js"],"names":["traverse","read","fs","readlink","path","buffer","Promise","resolve","reject","err","Buffer","toString","node","child","children","StringCids","map","Map","get","str","cid","undefined","set","DirContentCids","LinkContentCids","dirContent","nodes","data","name","nodeContent","reader","type","File","add","Directory","Symlink","start","size","finish","all","started","run"],"mappings":"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","file":"reading.js","sourcesContent":["// @flow\n\nimport type {Node} from './scanning';\nimport {FileReader} from './file-reader';\nimport * as fs from 'fs';\nimport {FileType} from './scanning';\nimport {padString, printLn, newCid} from './util';\n\nasync function readlink(path: string): Promise<string> {\n  let buffer = await new Promise((resolve, reject) => {\n    fs.readlink(path, (err, buffer) => {\n      err ? reject(err) : resolve(buffer);\n    });\n  });\n  return buffer instanceof Buffer ? buffer.toString() : buffer;\n}\n\nexport interface CompleteNode extends Node {\n  +cid: number;\n  +children: $ReadOnlyArray<CompleteNode>;\n}\n\nexport function* traverse(node: CompleteNode): Iterable<CompleteNode> {\n  yield node;\n  for (let child of node.children) {\n    yield* traverse(child);\n  }\n}\n\ninterface PendingNode extends Node {\n  +cid: Promise<number>;\n  +children: $ReadOnlyArray<PendingNode>;\n}\n\nclass StringCids {\n  map = new Map();\n  // noinspection JSUnusedGlobalSymbols\n  get(str: string): number {\n    let cid = this.map.get(str);\n    if (cid === undefined) {\n      cid = newCid();\n      this.map.set(str, cid);\n    }\n    return cid;\n  }\n}\n\nconst DirContentCids = new StringCids();\nconst LinkContentCids = new StringCids();\n\nasync function dirContent(nodes: $ReadOnlyArray<PendingNode>): Promise<string> {\n  let data = '';\n  for (let node of nodes) {\n    let {path, cid} = node;\n    data += padString((await cid) + '', 20) + ' ' + path.name + '\\n';\n  }\n  return data;\n}\n\nasync function nodeContent(node: Node, children: PendingNode[],\n       reader: FileReader): Promise<number> {\n  switch (node.type) {\n    case FileType.File:\n      return reader.add(node);\n    case FileType.Directory:\n      return DirContentCids.get(await dirContent(children));\n    case FileType.Symlink:\n      return LinkContentCids.get(await readlink(node.path.get()));\n    default:\n      // For types other than file, directory or symlink, just use the cid\n      // attached to the file type.\n      return node.type.cid;\n  }\n}\n\nfunction start(node: Node, reader: FileReader): PendingNode {\n  let {path, type, size} = node;\n  let children = node.children.map(node => start(node, reader));\n  let cid = nodeContent(node, children, reader);\n  return {path, size, children, type, cid};\n}\n\nasync function finish(node: PendingNode): Promise<CompleteNode> {\n  let {path, type, size} = node;\n  let children = await Promise.all(node.children.map(finish));\n  let cid = await node.cid;\n  return {path, size, type, cid, children};\n}\n\nexport async function read(nodes: Node[]): Promise<CompleteNode[]> {\n  await printLn('Reading file data');\n  let reader = new FileReader();\n  let started = nodes.map(node => start(node, reader));\n  await reader.run();\n  return await Promise.all(started.map(finish));\n}\n"]}