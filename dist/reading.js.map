{"version":3,"sources":["../src/reading.js"],"names":["traverse","read","fs","readlink","path","buffer","Promise","resolve","reject","err","Buffer","toString","node","child","children","StringIds","next","map","Map","get","str","id","undefined","set","dirContent","nodes","data","type","cid","name","nodeContent","reader","File","add","Directory","then","x","Symlink","start","size","finish","all","started","run"],"mappings":"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","file":"reading.js","sourcesContent":["// @flow\n\nimport type {Node} from './scanning';\nimport {FileReader} from './file-reader';\nimport * as fs from 'fs';\nimport {FileType} from './scanning';\nimport {pad} from './util';\n\nasync function readlink(path: string): Promise<string> {\n  let buffer = await new Promise((resolve, reject) => {\n    fs.readlink(path, (err, buffer) => {\n      err ? reject(err) : resolve(buffer);\n    });\n  });\n  return buffer instanceof Buffer ? buffer.toString() : buffer;\n}\n\nexport interface CompleteNode extends Node {\n  +cid: number;\n  +children: $ReadOnlyArray<CompleteNode>;\n}\n\nexport function* traverse(node: CompleteNode): Iterable<CompleteNode> {\n  yield node;\n  for (let child of node.children) {\n    yield* traverse(child);\n  }\n}\n\ninterface PendingNode extends Node {\n  +cid: Promise<number>;\n  +children: $ReadOnlyArray<PendingNode>;\n}\n\nconst StringIds = new class {\n  next = 1;\n  map = new Map();\n  // noinspection JSUnusedGlobalSymbols\n  get(str: string): number {\n    let id = this.map.get(str);\n    if (id === undefined) {\n      id = this.next++;\n      this.map.set(str, id);\n    }\n    return id;\n  }\n}();\n\nasync function dirContent(nodes: $ReadOnlyArray<PendingNode>): Promise<string> {\n  let data = '';\n  for (let node of nodes) {\n    let {path, type, cid} = node;\n    data += pad(type.name + ' ' + (await cid), 20) + ' ' + path.name + '\\n';\n  }\n  return data;\n}\n\nfunction nodeContent(node: Node, children: PendingNode[],\n    reader: FileReader): Promise<number> {\n  switch (node.type) {\n    case FileType.File:\n      return reader.add(node);\n    case FileType.Directory:\n      return dirContent(children).then(x => StringIds.get(x));\n    case FileType.Symlink:\n      return readlink(node.path.get()).then(x => StringIds.get(x));\n    default:\n      return Promise.resolve(0);\n  }\n}\n\nfunction start(node: Node, reader: FileReader): PendingNode {\n  let {path, size, type} = node;\n  let children = node.children.map(node => start(node, reader));\n  let cid = nodeContent(node, children, reader);\n  return {path, size, children, type, cid};\n}\n\nasync function finish(node: PendingNode): Promise<CompleteNode> {\n  let {path, size, type} = node;\n  let children = await Promise.all(node.children.map(finish));\n  let cid = await node.cid;\n  return {path, size, type, cid, children};\n}\n\nexport async function read(nodes: Node[]): Promise<CompleteNode[]> {\n  let reader = new FileReader();\n  let started = nodes.map(node => start(node, reader));\n  await reader.run();\n  return await Promise.all(started.map(finish));\n}\n"]}