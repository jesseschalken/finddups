{"version":3,"sources":["../src/reading.js"],"names":["traverse","read","fs","readlink","path","buffer","Promise","resolve","reject","err","Buffer","toString","node","child","children","StringIds","next","map","Map","get","str","id","undefined","set","dirContent","nodes","data","type","cid","key","name","nodeContent","reader","File","add","Directory","then","x","Symlink","start","size","finish","all","started","run"],"mappings":"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","file":"reading.js","sourcesContent":["// @flow\n\nimport type {Node} from './scanning';\nimport {FileReader} from './file-reader';\nimport * as fs from 'fs';\nimport {FileType} from './scanning';\nimport {padString, printLn} from './util';\n\nasync function readlink(path: string): Promise<string> {\n  let buffer = await new Promise((resolve, reject) => {\n    fs.readlink(path, (err, buffer) => {\n      err ? reject(err) : resolve(buffer);\n    });\n  });\n  return buffer instanceof Buffer ? buffer.toString() : buffer;\n}\n\nexport interface CompleteNode extends Node {\n  +cid: number;\n  +children: $ReadOnlyArray<CompleteNode>;\n}\n\nexport function* traverse(node: CompleteNode): Iterable<CompleteNode> {\n  yield node;\n  for (let child of node.children) {\n    yield* traverse(child);\n  }\n}\n\ninterface PendingNode extends Node {\n  +cid: Promise<number>;\n  +children: $ReadOnlyArray<PendingNode>;\n}\n\nconst StringIds = new class {\n  next = 1;\n  map = new Map();\n  // noinspection JSUnusedGlobalSymbols\n  get(str: string): number {\n    let id = this.map.get(str);\n    if (id === undefined) {\n      id = this.next++;\n      this.map.set(str, id);\n    }\n    return id;\n  }\n}();\n\nasync function dirContent(nodes: $ReadOnlyArray<PendingNode>): Promise<string> {\n  let data = '';\n  for (let node of nodes) {\n    let {path, type, cid} = node;\n    let key = type.name + ' ' + (await cid);\n    data += padString(key, 20) + ' ' + path.name + '\\n';\n  }\n  return data;\n}\n\nfunction nodeContent(node: Node, children: PendingNode[],\n    reader: FileReader): Promise<number> {\n  switch (node.type) {\n    case FileType.File:\n      return reader.add(node);\n    case FileType.Directory:\n      return dirContent(children).then(x => StringIds.get(x));\n    case FileType.Symlink:\n      return readlink(node.path.get()).then(x => StringIds.get(x));\n    default:\n      return Promise.resolve(0);\n  }\n}\n\nfunction start(node: Node, reader: FileReader): PendingNode {\n  let {path, size, type} = node;\n  let children = node.children.map(node => start(node, reader));\n  let cid = nodeContent(node, children, reader);\n  return {path, size, children, type, cid};\n}\n\nasync function finish(node: PendingNode): Promise<CompleteNode> {\n  let {path, size, type} = node;\n  let children = await Promise.all(node.children.map(finish));\n  let cid = await node.cid;\n  return {path, size, type, cid, children};\n}\n\nexport async function read(nodes: Node[]): Promise<CompleteNode[]> {\n  await printLn('Reading file data');\n  let reader = new FileReader();\n  let started = nodes.map(node => start(node, reader));\n  await reader.run();\n  return await Promise.all(started.map(finish));\n}\n"]}