{"version":3,"sources":["../src/file-reader.js"],"names":["fs","FileReader","files","add","file","Promise","resolve","reject","path","size","push","run","groups","groupFiles","group","cid","REGROUP_SIZE_BYTES","PRINT_PROGRESS_DELAY_MS","MAX_OPEN_FILES","groupBySize","todo","done","length","progress","streams","all","map","FileStream","open","regroupRecursive","stream","close","print","closed","eof","OpenFilesCounter","inc","self","fd","get","read","Math","min","buffer","total","dec","regroup","readSize","ceil","bytes","equals","every","groups2","Map","list","undefined","set","Array","from","values"],"mappings":"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","file":"file-reader.js","sourcesContent":["// @flow\n\nimport {Path, Node} from './scanning';\nimport * as fs from './promise_fs';\nimport {Progress} from './progress';\nimport {\n  AsyncCap,\n  newCid,\n  partition,\n  printLn,\n  shuffle,\n  sum,\n  trackProgress,\n  waitAll,\n} from './util';\nimport type {PendingPromise} from './util';\n\ninterface PendingFile extends PendingPromise<number> {\n  +path: Path;\n  +size: number;\n}\n\nexport class FileReader {\n  files: PendingFile[] = [];\n\n  add(file: Node): Promise<number> {\n    // `new Promise(cb)` executes `cb` synchronously, so once this method\n    // finishes we know the file has been added to `this.files`.\n    return new Promise((resolve, reject) => {\n      let {path, size} = file;\n      this.files.push({path, size, resolve, reject});\n    });\n  }\n\n  async run(): Promise<void> {\n    // Group our files together\n    let groups = await groupFiles(this.files);\n    // And resolve the group number for each file based on the group its in\n    for (let group of groups) {\n      let cid = newCid();\n      for (let file of group) {\n        file.resolve(cid);\n      }\n    }\n  }\n}\n\n/**\n * This is the number of bytes used by a single regrouping step. The size of\n * the chunk read from each file in a group is REGROUP_SIZE_BYTES divided by\n * the number of files in the group.\n *\n * The higher this is set, the fewer regrouping steps will be required to\n * finish a duplicate group and the fewer times the disk will have to switch\n * contexts between files, but the more memory the whole process will use.\n */\nconst REGROUP_SIZE_BYTES = 10 * 1024 * 1024;\n\n/**\n * Set this low enough that the user isn't sitting in front of their screen\n * wondering if the program has frozen but high enough that it won't blow\n * away all of their terminal scrollback.\n */\nconst PRINT_PROGRESS_DELAY_MS = 10000;\n\n/**\n * Set this lower than the maximum number of open files imposed by the\n * operating system, but higher than the number of files that might share\n * the same file size (since they will have to all be open at once to\n * regroup them).\n */\nconst MAX_OPEN_FILES = 2000;\n\nasync function groupFiles(files: PendingFile[]): Promise<PendingFile[][]> {\n  let groups = groupBySize(files);\n\n  await printLn('Reading file data of potential duplicates');\n\n  let [todo, done] = partition(groups, group => group.length > 1);\n  let progress = new Progress(\n    sum(todo, group => sum(group, file => file.size)),\n  );\n  // Small files are much slower to read than big files, so shuffle the list\n  // so that they are roughly evenly distributed and our time estimates are\n  // more likely to be correct.\n  shuffle(todo);\n  await trackProgress(\n    async () => {\n      for (let group of todo) {\n        // Open all the files in the group\n        let streams = await Promise.all(\n          group.map(file => FileStream.open(file, progress)),\n        );\n        // Progressively read the files to regroup them\n        for (let group of await regroupRecursive(streams)) {\n          done.push(group.map(stream => stream.file));\n        }\n        // Close all the files\n        await waitAll(streams.map(stream => stream.close()));\n      }\n    },\n    () => progress.print(),\n    PRINT_PROGRESS_DELAY_MS,\n  );\n  return done;\n}\n\nclass FileStream {\n  static OpenFilesCounter: AsyncCap = new AsyncCap(MAX_OPEN_FILES);\n\n  static async open(\n    file: PendingFile,\n    progress: Progress,\n  ): Promise<FileStream> {\n    await FileStream.OpenFilesCounter.inc();\n\n    let self = new FileStream();\n    self.fd = await fs.open(file.path.get(), 'r');\n    self.progress = progress;\n    self.file = file;\n    return self;\n  }\n\n  closed: boolean = false;\n  eof: boolean = false;\n  fd: number;\n  file: PendingFile;\n  progress: Progress;\n  done: number = 0;\n\n  /**\n   * Returns exactly the next `length` bytes, or fewer if end-of-file is\n   * reached.\n   */\n  async read(length: number): Promise<Buffer> {\n    // Don't bother allocating a buffer bigger than the remainder of the file\n    length = Math.min(length, this.file.size - this.done);\n\n    let buffer = await fs.read(this.fd, length);\n\n    if (buffer.length === 0) {\n      this.eof = true;\n      // Might as well close the file handle off as soon as possible to free\n      // up the open file handle count.\n      await this.close();\n    }\n    this.done += buffer.length;\n    this.progress.done += buffer.length;\n\n    return buffer;\n  }\n\n  async close(): Promise<void> {\n    if (!this.closed) {\n      this.closed = true;\n      await fs.close(this.fd);\n\n      // Remove any bytes we didn't read from the progress bar\n      this.progress.total -= this.file.size - this.done;\n\n      FileStream.OpenFilesCounter.dec();\n    }\n  }\n}\n\nasync function regroup(files: FileStream[]): Promise<FileStream[][]> {\n  const groups = [];\n  // Divide the regroup size by the number of files we have, otherwise we\n  // could exhaust our memory just by having a large enough number of in our\n  // group.\n  const readSize = Math.ceil(REGROUP_SIZE_BYTES / files.length);\n  // For each file, in parallel, read the next readSize bytes and add\n  // the file to the group for those bytes\n  await waitAll(\n    files.map(async file => {\n      let bytes = await file.read(readSize);\n      for (let group of groups) {\n        if (group.bytes.equals(bytes)) {\n          group.files.push(file);\n          return;\n        }\n      }\n      groups.push({bytes, files: [file]});\n    }),\n  );\n  // Return the files from each group\n  return groups.map(group => group.files);\n}\n\nasync function regroupRecursive(files: FileStream[]): Promise<FileStream[][]> {\n  if (files.length === 0) {\n    // Not sure why we were given an empty group but whatever\n    return [];\n  } else if (files.length === 1 || files.every(file => file.eof)) {\n    // Terminal case. A group with only one element in it or where every\n    // file has reached EOF is finished. Close them off and return the\n    // group back. Close all the files in parallel.\n    await waitAll(files.map(file => file.close()));\n    return [files];\n  } else {\n    // If the group has multiple files in it and they are not at EOF then\n    // we need to read more of the files to determine if they are actual\n    // duplicates. Regroup the files based on the next set of bytes and\n    // recurse on the new groups.\n    let groups = await regroup(files);\n    if (groups.length === 1) {\n      // Tail call so our stack doesn't grow forever\n      return regroupRecursive(groups[0]);\n    } else {\n      let groups2 = [];\n      // It is important that we don't do the regrouping here in parallel,\n      // otherwise the disk read requests will ping pong between different\n      // groups which isn't nice on the disk cache.\n      for (let files of groups) {\n        for (let group of await regroupRecursive(files)) {\n          groups2.push(group);\n        }\n      }\n      return groups2;\n    }\n  }\n}\n\nfunction groupBySize(files: PendingFile[]): PendingFile[][] {\n  let map = new Map();\n  for (let file of files) {\n    let list = map.get(file.size);\n    if (list === undefined) {\n      map.set(file.size, [file]);\n    } else {\n      list.push(file);\n    }\n  }\n  return Array.from(map.values());\n}\n"]}