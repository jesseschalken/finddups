{"version":3,"sources":["../src/file-reader.js"],"names":["fs","FileReader","files","add","file","Promise","resolve","reject","path","size","push","run","groups","groupFiles","i","length","groups1","groupBySize","groups2","waitAll","map","group","group2","regroupRecursive","OpenFile","constructor","closed","eof","fd","openFd","get","read","Buffer","alloc","buffer","readFd","close","closeFd","fdCounter","count","queue","inc","dec","shift","open","err","allocUnsafe","bytesRead","slice","promises","promise","findGroup","bytes","equals","CHUNK_SIZE","regroup","every","ret","Map","list","undefined","set","Array","from","values"],"mappings":"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","file":"file-reader.js","sourcesContent":["// @flow\n\nimport {Path, Node} from './scanning';\nimport * as fs from 'fs';\n\ninterface PendingPromise<T> {\n  +resolve: T => void;\n  +reject: mixed => void;\n}\n\ninterface PendingFile extends PendingPromise<number> {\n  +path: Path;\n  +size: number;\n}\n\nexport class FileReader {\n  files: PendingFile[] = [];\n\n  add(file: Node): Promise<number> {\n    // `new Promise(cb)` executes `cb` synchronously, so once this method\n    // finishes we know the file has been added to `this.files`.\n    return new Promise((resolve, reject) => {\n      let {path, size} = file;\n      this.files.push({path, size, resolve, reject});\n    });\n  }\n\n  async run(): Promise<void> {\n    // Group our files together\n    let groups = await groupFiles(this.files);\n    // And resolve the group number for each file based on the group its in\n    for (let i = 0; i < groups.length; i++) {\n      for (let file of groups[i]) {\n        file.resolve(i);\n      }\n    }\n  }\n}\n\nasync function groupFiles(files: PendingFile[]): Promise<PendingFile[][]> {\n  let groups1 = groupBySize(files);\n  let groups2 = [];\n  await waitAll(groups1.map(async group => {\n    if (group.length > 1) {\n      for (let group2 of\n          await regroupRecursive(group.map(file => new OpenFile(file)))) {\n        groups2.push(group2.map(file => file.file));\n      }\n    } else {\n      groups2.push(group);\n    }\n  }));\n  return groups2;\n}\n\nclass OpenFile {\n  closed: boolean = false;\n  eof: boolean = false;\n  fd: Promise<number>;\n  file: PendingFile;\n\n  constructor(file: PendingFile) {\n    this.file = file;\n    this.fd = openFd(file.path.get());\n  }\n\n  /**\n   * Returns exactly the next `length` bytes, or fewer if end-of-file is\n   * reached.\n   */\n  async read(length: number): Promise<Buffer> {\n    if (this.closed || length === 0) {\n      return Buffer.alloc(0);\n    }\n    let buffer = await readFd(await this.fd, length);\n    if (buffer.length === 0) {\n      this.eof = true;\n      await this.close();\n    }\n    return buffer;\n  }\n\n  async close(): Promise<void> {\n    // Gate to make sure only the first call to close() will close the file\n    // handle.\n    if (!this.closed) {\n      this.closed = true;\n      await closeFd(await this.fd);\n    }\n  }\n}\n\nconst fdCounter = new class {\n  count: number = 0;\n  queue: PendingPromise<void>[] = [];\n  // noinspection JSUnusedGlobalSymbols\n  inc(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.queue.push({resolve, reject});\n      this.run();\n    });\n  }\n  // noinspection JSUnusedGlobalSymbols\n  dec(): void {\n    this.count--;\n    this.run();\n  }\n  run(): void {\n    while (this.queue.length > 0 && this.count < 1000) {\n      this.count++;\n      this.queue.shift().resolve();\n    }\n  }\n}();\n\nasync function openFd(path: string): Promise<number> {\n  // Make sure there are less than 1000 open file descriptors before opening\n  // more of them.\n  await fdCounter.inc();\n  return new Promise((resolve, reject) => {\n    fs.open(path, 'r', (err, fd) => {\n      err ? reject(err) : resolve(fd);\n    });\n  });\n}\n\nasync function readFd(fd: number, length: number): Promise<Buffer> {\n  let buffer = Buffer.allocUnsafe(length);\n  let bytesRead = await new Promise((resolve, reject) => {\n    // noinspection JSIgnoredPromiseFromCall\n    fs.read(fd, buffer, 0, length, null, (err, bytesRead) => {\n      err ? reject(err) : resolve(bytesRead);\n    });\n  });\n  if (bytesRead < length) {\n    buffer = buffer.slice(0, bytesRead);\n  }\n  return buffer;\n}\n\nfunction closeFd(fd: number): Promise<void> {\n  fdCounter.dec();\n  return new Promise((resolve, reject) => {\n    fs.close(fd, err => {\n      err ? reject(err) : resolve();\n    });\n  });\n}\n\n/** Promise.all but without building an array of return values */\nasync function waitAll(promises: Iterable<Promise<void>>): Promise<void> {\n  for (let promise of promises) {\n    await promise;\n  }\n}\n\ntype Group = {+bytes: Buffer, +files: OpenFile[]};\n\nfunction findGroup(groups: Group[], bytes: Buffer): Group {\n  for (let group of groups) {\n    if (group.bytes.equals(bytes)) {\n      return group;\n    }\n  }\n  let group = {bytes, files: []};\n  groups.push(group);\n  return group;\n}\n\nconst CHUNK_SIZE = 10 * 1024 * 1024;\n\nasync function regroup(files: OpenFile[]): Promise<OpenFile[][]> {\n  let groups: Group[] = [];\n  // For each file, in parallel, read the next CHUNK_SIZE bytes and add the\n  // file to the group for those bytes\n  await waitAll(files.map(async file => {\n    let bytes = await file.read(CHUNK_SIZE);\n    let group = findGroup(groups, bytes);\n    group.files.push(file);\n  }));\n  // Return the files from each group\n  return groups.map(group => group.files);\n}\n\nasync function regroupRecursive(files: OpenFile[]): Promise<OpenFile[][]> {\n  if (files.length === 0) {\n    // Not sure why we were given an empty group but whatever\n    return [];\n  } else if (files.length === 1 || files.every(file => file.eof)) {\n    // Terminal case. A group with only one element in it or where every\n    // file has reached EOF is finished. Close them off and return the\n    // group back. Close all the files in parallel.\n    await waitAll(files.map(file => file.close()));\n    return [files];\n  } else {\n    // If the group has multiple files in it and they are not at EOF then\n    // we need to read more of the files to determine if they are actual\n    // duplicates. Regroup the files based on the next set of bytes and\n    // recurse on the new groups.\n    let groups = await regroup(files);\n    if (groups.length === 1) {\n      // Tail call so our stack doesn't grow forever\n      return regroupRecursive(groups[0]);\n    } else {\n      let ret = [];\n      await waitAll(groups.map(async files => {\n        for (let group of await regroupRecursive(files)) {\n          ret.push(group);\n        }\n      }));\n      return ret;\n    }\n  }\n}\n\nfunction groupBySize(files: PendingFile[]): PendingFile[][] {\n  let map = new Map();\n  for (let file of files) {\n    let list = map.get(file.size);\n    if (list === undefined) {\n      list = [];\n      map.set(file.size, list);\n    }\n    list.push(file);\n  }\n  return Array.from(map.values());\n}\n"]}