{"version":3,"sources":["../src/file-reader.js"],"names":["fs","FileReader","files","add","file","Promise","resolve","reject","path","size","push","run","groups","groupFiles","group","cid","REGROUP_SIZE_BYTES","PRINT_PROGRESS_DELAY_MS","MAX_OPEN_FILES","groupBySize","progress","groups2","todo","length","total","streams","all","map","FileStream","open","regroupRecursive","stream","close","print","closed","eof","done","OpenFilesCounter","inc","self","fd","get","read","Math","min","buffer","dec","regroup","readSize","ceil","bytes","equals","every","Map","list","undefined","set","Array","from","values"],"mappings":"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","file":"file-reader.js","sourcesContent":["// @flow\n\nimport {Path, Node} from './scanning';\nimport * as fs from './promise_fs';\nimport {Progress} from './progress';\nimport {\n  AsyncCap,\n  newCid,\n  printLn,\n  shuffle,\n  sum,\n  trackProgress,\n  waitAll,\n} from './util';\nimport type {PendingPromise} from './util';\n\ninterface PendingFile extends PendingPromise<number> {\n  +path: Path;\n  +size: number;\n}\n\nexport class FileReader {\n  files: PendingFile[] = [];\n\n  // noinspection JSUnusedGlobalSymbols\n  add(file: Node): Promise<number> {\n    // `new Promise(cb)` executes `cb` synchronously, so once this method\n    // finishes we know the file has been added to `this.files`.\n    return new Promise((resolve, reject) => {\n      let {path, size} = file;\n      this.files.push({path, size, resolve, reject});\n    });\n  }\n\n  async run(): Promise<void> {\n    // Group our files together\n    let groups = await groupFiles(this.files);\n    // And resolve the group number for each file based on the group its in\n    for (let group of groups) {\n      let cid = newCid();\n      for (let file of group) {\n        file.resolve(cid);\n      }\n    }\n  }\n}\n\n/**\n * This is the number of bytes used by a single regrouping step. The size of\n * the chunk read from each file in a group is REGROUP_SIZE_BYTES divided by\n * the number of files in the group.\n *\n * The higher this is set, the fewer regrouping steps will be required to\n * finish a duplicate group and the fewer times the disk will have to switch\n * contexts between files, but the more memory the whole process will use.\n */\nconst REGROUP_SIZE_BYTES = 10 * 1024 * 1024;\n\n/**\n * Set this low enough that the user isn't sitting in front of their screen\n * wondering if the program has frozen but high enough that it won't blow\n * away all of their terminal scrollback.\n */\nconst PRINT_PROGRESS_DELAY_MS = 10000;\n\n/**\n * Set this lower than the maximum number of open files imposed by the\n * operating system, but higher than the number of files that might share\n * the same file size (since they will have to all be open at once to\n * regroup them).\n */\nconst MAX_OPEN_FILES = 2000;\n\nasync function groupFiles(files: PendingFile[]): Promise<PendingFile[][]> {\n  const groups = groupBySize(files);\n\n  // Small files are much slower to read than big files, so shuffle the list\n  // so that they are roughly evenly distributed and our time estimates are\n  // more likely to be correct.\n  shuffle(groups);\n\n  await printLn('Reading file data of potential duplicates');\n  let progress = new Progress();\n  let groups2 = [];\n  let todo = [];\n  for (let group of groups) {\n    if (group.length > 1) {\n      progress.total += sum(group, file => file.size);\n      todo.push(group);\n    } else {\n      groups2.push(group);\n    }\n  }\n  await trackProgress(\n    async () => {\n      for (let group of todo) {\n        // Open all the files in the group\n        let streams = await Promise.all(\n          group.map(file => FileStream.open(file, progress)),\n        );\n        // Progressively read the files to regroup them\n        for (let group of await regroupRecursive(streams)) {\n          groups2.push(group.map(stream => stream.file));\n        }\n        // Close all the files\n        await waitAll(streams.map(stream => stream.close()));\n      }\n    },\n    () => progress.print(),\n    PRINT_PROGRESS_DELAY_MS,\n  );\n  return groups2;\n}\n\nclass FileStream {\n  static OpenFilesCounter: AsyncCap = new AsyncCap(MAX_OPEN_FILES);\n\n  static async open(\n    file: PendingFile,\n    progress: Progress,\n  ): Promise<FileStream> {\n    await FileStream.OpenFilesCounter.inc();\n\n    let self = new FileStream();\n    self.fd = await fs.open(file.path.get(), 'r');\n    self.progress = progress;\n    self.file = file;\n    return self;\n  }\n\n  closed: boolean = false;\n  eof: boolean = false;\n  fd: number;\n  file: PendingFile;\n  progress: Progress;\n  done: number = 0;\n\n  /**\n   * Returns exactly the next `length` bytes, or fewer if end-of-file is\n   * reached.\n   */\n  async read(length: number): Promise<Buffer> {\n    // Don't bother allocating a buffer bigger than the remainder of the file\n    length = Math.min(length, this.file.size - this.done);\n\n    let buffer = await fs.read(this.fd, length);\n\n    if (buffer.length === 0) {\n      this.eof = true;\n      // Might as well close the file handle off as soon as possible to free\n      // up the open file handle count.\n      await this.close();\n    }\n    this.done += buffer.length;\n    this.progress.done += buffer.length;\n\n    return buffer;\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  async close(): Promise<void> {\n    if (!this.closed) {\n      this.closed = true;\n      await fs.close(this.fd);\n\n      // Remove any bytes we didn't read from the progress bar\n      this.progress.total -= this.file.size - this.done;\n\n      FileStream.OpenFilesCounter.dec();\n    }\n  }\n}\n\nasync function regroup(files: FileStream[]): Promise<FileStream[][]> {\n  const groups = [];\n  // Divide the regroup size by the number of files we have, otherwise we\n  // could exhaust our memory just by having a large enough number of in our\n  // group.\n  const readSize = Math.ceil(REGROUP_SIZE_BYTES / files.length);\n  // For each file, in parallel, read the next readSize bytes and add\n  // the file to the group for those bytes\n  await waitAll(\n    files.map(async file => {\n      let bytes = await file.read(readSize);\n      for (let group of groups) {\n        if (group.bytes.equals(bytes)) {\n          group.files.push(file);\n          return;\n        }\n      }\n      groups.push({bytes, files: [file]});\n    }),\n  );\n  // Return the files from each group\n  return groups.map(group => group.files);\n}\n\nasync function regroupRecursive(files: FileStream[]): Promise<FileStream[][]> {\n  if (files.length === 0) {\n    // Not sure why we were given an empty group but whatever\n    return [];\n  } else if (files.length === 1 || files.every(file => file.eof)) {\n    // Terminal case. A group with only one element in it or where every\n    // file has reached EOF is finished. Close them off and return the\n    // group back. Close all the files in parallel.\n    await waitAll(files.map(file => file.close()));\n    return [files];\n  } else {\n    // If the group has multiple files in it and they are not at EOF then\n    // we need to read more of the files to determine if they are actual\n    // duplicates. Regroup the files based on the next set of bytes and\n    // recurse on the new groups.\n    let groups = await regroup(files);\n    if (groups.length === 1) {\n      // Tail call so our stack doesn't grow forever\n      return regroupRecursive(groups[0]);\n    } else {\n      let groups2 = [];\n      // It is important that we don't do the regrouping here in parallel,\n      // otherwise the disk read requests will ping pong between different\n      // groups which isn't nice on the disk cache.\n      for (let files of groups) {\n        for (let group of await regroupRecursive(files)) {\n          groups2.push(group);\n        }\n      }\n      return groups2;\n    }\n  }\n}\n\nfunction groupBySize(files: PendingFile[]): PendingFile[][] {\n  let map = new Map();\n  for (let file of files) {\n    let list = map.get(file.size);\n    if (list === undefined) {\n      map.set(file.size, [file]);\n    } else {\n      list.push(file);\n    }\n  }\n  return Array.from(map.values());\n}\n"]}