{"version":3,"sources":["../src/file-reader.js"],"names":["fs","FileReader","files","add","file","Promise","resolve","reject","path","size","push","run","groups","groupFiles","i","length","groups1","groupBySize","progress","interval","print","groups2","waitAll","map","group","group2","regroupRecursive","OpenFile","stop","constructor","closed","eof","done","total","fd","openFd","get","read","Buffer","alloc","buffer","readFd","close","closeFd","fdCounter","count","queue","inc","dec","shift","open","err","allocUnsafe","bytesRead","slice","promises","promise","findGroup","bytes","equals","CHUNK_SIZE","regroup","every","ret","Map","list","undefined","set","Array","from","values"],"mappings":"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","file":"file-reader.js","sourcesContent":["// @flow\n\nimport {Path, Node} from './scanning';\nimport * as fs from 'fs';\nimport {Progress} from './progress';\nimport {Interval} from './util';\n\ninterface PendingPromise<T> {\n  +resolve: T => void;\n  +reject: mixed => void;\n}\n\ninterface PendingFile extends PendingPromise<number> {\n  +path: Path;\n  +size: number;\n}\n\nexport class FileReader {\n  files: PendingFile[] = [];\n\n  add(file: Node): Promise<number> {\n    // `new Promise(cb)` executes `cb` synchronously, so once this method\n    // finishes we know the file has been added to `this.files`.\n    return new Promise((resolve, reject) => {\n      let {path, size} = file;\n      this.files.push({path, size, resolve, reject});\n    });\n  }\n\n  async run(): Promise<void> {\n    // Group our files together\n    let groups = await groupFiles(this.files);\n    // And resolve the group number for each file based on the group its in\n    for (let i = 0; i < groups.length; i++) {\n      for (let file of groups[i]) {\n        file.resolve(i);\n      }\n    }\n  }\n}\n\nasync function groupFiles(files: PendingFile[]): Promise<PendingFile[][]> {\n  let groups1 = groupBySize(files);\n  let progress = new Progress();\n  let interval = new Interval(() => progress.print(), 1000);\n  let groups2 = [];\n  await waitAll(groups1.map(async group => {\n    if (group.length > 1) {\n      for (let group2 of\n          await regroupRecursive(\n              group.map(file => new OpenFile(file, progress)))) {\n        groups2.push(group2.map(file => file.file));\n      }\n    } else {\n      groups2.push(group);\n    }\n  }));\n  interval.stop();\n  await progress.print();\n  return groups2;\n}\n\nclass OpenFile {\n  closed: boolean = false;\n  eof: boolean = false;\n  fd: Promise<number>;\n  file: PendingFile;\n  progress: Progress;\n  done: number = 0;\n\n  constructor(file: PendingFile, progress: Progress) {\n    progress.total += file.size;\n\n    this.file = file;\n    this.fd = openFd(file.path.get());\n    this.progress = progress;\n  }\n\n  /**\n   * Returns exactly the next `length` bytes, or fewer if end-of-file is\n   * reached.\n   */\n  async read(length: number): Promise<Buffer> {\n    if (this.closed || length === 0) {\n      return Buffer.alloc(0);\n    }\n    let buffer = await readFd(await this.fd, length);\n    if (buffer.length === 0) {\n      this.eof = true;\n      await this.close();\n    }\n\n    // Update the progress bar\n    this.done += buffer.length;\n    this.progress.done += buffer.length;\n\n    return buffer;\n  }\n\n  async close(): Promise<void> {\n    // Gate to make sure only the first call to close() will close the file\n    // handle.\n    if (!this.closed) {\n      this.closed = true;\n      await closeFd(await this.fd);\n\n      // Remove any bytes we didn't read from the progress bar\n      this.progress.total -= (this.file.size - this.done);\n    }\n  }\n}\n\nconst fdCounter = new class {\n  count: number = 0;\n  queue: PendingPromise<void>[] = [];\n  // noinspection JSUnusedGlobalSymbols\n  inc(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.queue.push({resolve, reject});\n      this.run();\n    });\n  }\n  // noinspection JSUnusedGlobalSymbols\n  dec(): void {\n    this.count--;\n    this.run();\n  }\n  run(): void {\n    while (this.queue.length > 0 && this.count < 1000) {\n      this.count++;\n      this.queue.shift().resolve();\n    }\n  }\n}();\n\nasync function openFd(path: string): Promise<number> {\n  // Make sure there are less than 1000 open file descriptors before opening\n  // more of them.\n  await fdCounter.inc();\n  return new Promise((resolve, reject) => {\n    fs.open(path, 'r', (err, fd) => {\n      err ? reject(err) : resolve(fd);\n    });\n  });\n}\n\nasync function readFd(fd: number, length: number): Promise<Buffer> {\n  let buffer = Buffer.allocUnsafe(length);\n  let bytesRead = await new Promise((resolve, reject) => {\n    // noinspection JSIgnoredPromiseFromCall\n    fs.read(fd, buffer, 0, length, null, (err, bytesRead) => {\n      err ? reject(err) : resolve(bytesRead);\n    });\n  });\n  if (bytesRead < length) {\n    buffer = buffer.slice(0, bytesRead);\n  }\n  return buffer;\n}\n\nfunction closeFd(fd: number): Promise<void> {\n  fdCounter.dec();\n  return new Promise((resolve, reject) => {\n    fs.close(fd, err => {\n      err ? reject(err) : resolve();\n    });\n  });\n}\n\n/** Promise.all but without building an array of return values */\nasync function waitAll(promises: Iterable<Promise<void>>): Promise<void> {\n  for (let promise of promises) {\n    await promise;\n  }\n}\n\ntype Group = {+bytes: Buffer, +files: OpenFile[]};\n\nfunction findGroup(groups: Group[], bytes: Buffer): Group {\n  for (let group of groups) {\n    if (group.bytes.equals(bytes)) {\n      return group;\n    }\n  }\n  let group = {bytes, files: []};\n  groups.push(group);\n  return group;\n}\n\nconst CHUNK_SIZE = 10 * 1024 * 1024;\n\nasync function regroup(files: OpenFile[]): Promise<OpenFile[][]> {\n  let groups: Group[] = [];\n  // For each file, in parallel, read the next CHUNK_SIZE bytes and add the\n  // file to the group for those bytes\n  await waitAll(files.map(async file => {\n    let bytes = await file.read(CHUNK_SIZE);\n    let group = findGroup(groups, bytes);\n    group.files.push(file);\n  }));\n  // Return the files from each group\n  return groups.map(group => group.files);\n}\n\nasync function regroupRecursive(files: OpenFile[]): Promise<OpenFile[][]> {\n  if (files.length === 0) {\n    // Not sure why we were given an empty group but whatever\n    return [];\n  } else if (files.length === 1 || files.every(file => file.eof)) {\n    // Terminal case. A group with only one element in it or where every\n    // file has reached EOF is finished. Close them off and return the\n    // group back. Close all the files in parallel.\n    await waitAll(files.map(file => file.close()));\n    return [files];\n  } else {\n    // If the group has multiple files in it and they are not at EOF then\n    // we need to read more of the files to determine if they are actual\n    // duplicates. Regroup the files based on the next set of bytes and\n    // recurse on the new groups.\n    let groups = await regroup(files);\n    if (groups.length === 1) {\n      // Tail call so our stack doesn't grow forever\n      return regroupRecursive(groups[0]);\n    } else {\n      let ret = [];\n      await waitAll(groups.map(async files => {\n        for (let group of await regroupRecursive(files)) {\n          ret.push(group);\n        }\n      }));\n      return ret;\n    }\n  }\n}\n\nfunction groupBySize(files: PendingFile[]): PendingFile[][] {\n  let map = new Map();\n  for (let file of files) {\n    let list = map.get(file.size);\n    if (list === undefined) {\n      list = [];\n      map.set(file.size, list);\n    }\n    list.push(file);\n  }\n  return Array.from(map.values());\n}\n"]}