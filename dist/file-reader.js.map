{"version":3,"sources":["../src/file-reader.js"],"names":["fs","FileReader","files","add","file","Promise","resolve","reject","path","size","push","run","groups","groupFiles","group","cid","REGROUP_SIZE_BYTES","MAX_CONCURRENT_REGROUPS","PRINT_PROGRESS_DELAY_MS","MAX_OPEN_FILES","groupBySize","progress","counter","groups2","map","length","total","inc","streams","all","FileStream","open","regroupRecursive","stream","close","dec","print","closed","eof","done","OpenFilesCounter","self","fd","get","read","Math","min","buffer","regroup","getGroup","bytes","equals","readSize","ceil","every","Map","list","undefined","set","Array","from","values"],"mappings":"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","file":"file-reader.js","sourcesContent":["// @flow\n\nimport {Path, Node} from './scanning';\nimport * as fs from './promise_fs';\nimport {Progress} from './progress';\nimport {\n  AsyncCap,\n  newCid,\n  printLn,\n  shuffle,\n  sum,\n  trackProgress,\n  waitAll,\n} from './util';\nimport type {PendingPromise} from './util';\n\ninterface PendingFile extends PendingPromise<number> {\n  +path: Path;\n  +size: number;\n}\n\nexport class FileReader {\n  files: PendingFile[] = [];\n\n  // noinspection JSUnusedGlobalSymbols\n  add(file: Node): Promise<number> {\n    // `new Promise(cb)` executes `cb` synchronously, so once this method\n    // finishes we know the file has been added to `this.files`.\n    return new Promise((resolve, reject) => {\n      let {path, size} = file;\n      this.files.push({path, size, resolve, reject});\n    });\n  }\n\n  async run(): Promise<void> {\n    // Group our files together\n    let groups = await groupFiles(this.files);\n    // And resolve the group number for each file based on the group its in\n    for (let group of groups) {\n      let cid = newCid();\n      for (let file of group) {\n        file.resolve(cid);\n      }\n    }\n  }\n}\n\nconst REGROUP_SIZE_BYTES = 10 * 1024 * 1024;\nconst MAX_CONCURRENT_REGROUPS = 10;\nconst PRINT_PROGRESS_DELAY_MS = 10000;\nconst MAX_OPEN_FILES = 2000;\n\nasync function groupFiles(files: PendingFile[]): Promise<PendingFile[][]> {\n  const groups = groupBySize(files);\n\n  // Small files are much slower to read than big files, so shuffle the list\n  // so that they are roughly evenly distributed and our time estimates are\n  // more likely to be correct.\n  shuffle(groups);\n\n  await printLn('Reading file data of potential duplicates');\n  let progress = new Progress();\n  let counter = new AsyncCap(MAX_CONCURRENT_REGROUPS);\n  let groups2 = [];\n  await trackProgress(\n    () =>\n      waitAll(\n        groups.map(async group => {\n          if (group.length > 1) {\n            progress.total += sum(group, file => file.size);\n            await counter.inc();\n            // Open all the files in the group\n            let streams = await Promise.all(\n              group.map(file => FileStream.open(file, progress)),\n            );\n            // Progressively read the files to regroup them\n            for (let group of await regroupRecursive(streams)) {\n              groups2.push(group.map(stream => stream.file));\n            }\n            // Close all the files\n            await waitAll(streams.map(stream => stream.close()));\n            counter.dec();\n          } else {\n            groups2.push(group);\n          }\n        }),\n      ),\n    () => progress.print(),\n    PRINT_PROGRESS_DELAY_MS,\n  );\n  return groups2;\n}\n\nclass FileStream {\n  static OpenFilesCounter: AsyncCap = new AsyncCap(MAX_OPEN_FILES);\n\n  static async open(\n    file: PendingFile,\n    progress: Progress,\n  ): Promise<FileStream> {\n    await FileStream.OpenFilesCounter.inc();\n\n    let self = new FileStream();\n    self.fd = await fs.open(file.path.get(), 'r');\n    self.progress = progress;\n    self.file = file;\n    return self;\n  }\n\n  closed: boolean = false;\n  eof: boolean = false;\n  fd: number;\n  file: PendingFile;\n  progress: Progress;\n  done: number = 0;\n\n  /**\n   * Returns exactly the next `length` bytes, or fewer if end-of-file is\n   * reached.\n   */\n  async read(length: number): Promise<Buffer> {\n    // Don't bother allocating a buffer bigger than the remainder of the file\n    length = Math.min(length, this.file.size - this.done);\n\n    let buffer = await fs.read(this.fd, length);\n\n    if (buffer.length === 0) {\n      this.eof = true;\n      // Might as well close the file handle off as soon as possible to free\n      // up the open file handle count.\n      await this.close();\n    }\n    this.done += buffer.length;\n    this.progress.done += buffer.length;\n\n    return buffer;\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  async close(): Promise<void> {\n    if (!this.closed) {\n      this.closed = true;\n      await fs.close(this.fd);\n\n      // Remove any bytes we didn't read from the progress bar\n      this.progress.total -= this.file.size - this.done;\n\n      FileStream.OpenFilesCounter.dec();\n    }\n  }\n}\n\nasync function regroup(files: FileStream[]): Promise<FileStream[][]> {\n  let groups = [];\n  function getGroup(bytes) {\n    for (let group of groups) {\n      if (group.bytes.equals(bytes)) {\n        return group;\n      }\n    }\n    let group = {bytes, files: []};\n    groups.push(group);\n    return group;\n  }\n  // Divide the regroup size by the number of files we have, otherwise we\n  // could exhaust our memory just by having a large enough number of in our\n  // group.\n  const readSize = Math.ceil(REGROUP_SIZE_BYTES / files.length);\n  // For each file, in parallel, read the next readSize bytes and add\n  // the file to the group for those bytes\n  await waitAll(\n    files.map(async file => {\n      let bytes = await file.read(readSize);\n      let group = getGroup(bytes);\n      group.files.push(file);\n    }),\n  );\n  // Return the files from each group\n  return groups.map(group => group.files);\n}\n\nasync function regroupRecursive(files: FileStream[]): Promise<FileStream[][]> {\n  if (files.length === 0) {\n    // Not sure why we were given an empty group but whatever\n    return [];\n  } else if (files.length === 1 || files.every(file => file.eof)) {\n    // Terminal case. A group with only one element in it or where every\n    // file has reached EOF is finished. Close them off and return the\n    // group back. Close all the files in parallel.\n    await waitAll(files.map(file => file.close()));\n    return [files];\n  } else {\n    // If the group has multiple files in it and they are not at EOF then\n    // we need to read more of the files to determine if they are actual\n    // duplicates. Regroup the files based on the next set of bytes and\n    // recurse on the new groups.\n    let groups = await regroup(files);\n    if (groups.length === 1) {\n      // Tail call so our stack doesn't grow forever\n      return regroupRecursive(groups[0]);\n    } else {\n      let groups2 = [];\n      // It is important that we don't do the regrouping here in parallel,\n      // otherwise the disk read requests will ping pong between different\n      // groups which isn't nice on the disk cache.\n      for (let files of groups) {\n        for (let group of await regroupRecursive(files)) {\n          groups2.push(group);\n        }\n      }\n      return groups2;\n    }\n  }\n}\n\nfunction groupBySize(files: PendingFile[]): PendingFile[][] {\n  let map = new Map();\n  for (let file of files) {\n    let list = map.get(file.size);\n    if (list === undefined) {\n      map.set(file.size, [file]);\n    } else {\n      list.push(file);\n    }\n  }\n  return Array.from(map.values());\n}\n"]}