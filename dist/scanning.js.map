{"version":3,"sources":["../src/scanning.js"],"names":["traverse","scan","fs","FileType","create","stat","isFile","File","isDirectory","Directory","isSymbolicLink","Symlink","isBlockDevice","BlockDev","isCharacterDevice","CharDev","isFIFO","FIFO","isSocket","Socket","Unknown","constructor","name","Path","parent","get","join","node","child","children","lstat","path","Promise","resolve","reject","err","readdir","names","createNode","pathStr","type","size","all","map","paths","count","roots","root","push"],"mappings":";;;;;;QA4DiBA,Q,GAAAA,Q;QAqCKC,I,GAAAA,I;;AAhGtB;;IAAYC,E;;AACZ;;AACA;;;;AAEO,MAAMC,QAAN,CAAe;AACpB,SAAOC,MAAP,CAAcC,IAAd,EAAwC;AACtC,QAAIA,KAAKC,MAAL,EAAJ,EAAmB,OAAOH,SAASI,IAAhB;AACnB,QAAIF,KAAKG,WAAL,EAAJ,EAAwB,OAAOL,SAASM,SAAhB;AACxB,QAAIJ,KAAKK,cAAL,EAAJ,EAA2B,OAAOP,SAASQ,OAAhB;AAC3B,QAAIN,KAAKO,aAAL,EAAJ,EAA0B,OAAOT,SAASU,QAAhB;AAC1B,QAAIR,KAAKS,iBAAL,EAAJ,EAA8B,OAAOX,SAASY,OAAhB;AAC9B,QAAIV,KAAKW,MAAL,EAAJ,EAAmB,OAAOb,SAASc,IAAhB;AACnB,QAAIZ,KAAKa,QAAL,EAAJ,EAAqB,OAAOf,SAASgB,MAAhB;AACrB,WAAOhB,SAASiB,OAAhB;AACD;;AAYDC,cAAYC,IAAZ,EAA0B;AACxB,SAAKA,IAAL,GAAYA,IAAZ;AACD;AAxBmB;;QAATnB,Q,GAAAA,Q,EA2Bb;;;;;;AA3BaA,Q,CAYJI,I,GAAO,IAAIJ,QAAJ,CAAa,MAAb,C;AAZHA,Q,CAaJM,S,GAAY,IAAIN,QAAJ,CAAa,KAAb,C;AAbRA,Q,CAcJQ,O,GAAU,IAAIR,QAAJ,CAAa,MAAb,C;AAdNA,Q,CAeJU,Q,GAAW,IAAIV,QAAJ,CAAa,OAAb,C;AAfPA,Q,CAgBJY,O,GAAU,IAAIZ,QAAJ,CAAa,MAAb,C;AAhBNA,Q,CAiBJc,I,GAAO,IAAId,QAAJ,CAAa,MAAb,C;AAjBHA,Q,CAkBJgB,M,GAAS,IAAIhB,QAAJ,CAAa,QAAb,C;AAlBLA,Q,CAmBJiB,O,GAAU,IAAIjB,QAAJ,CAAa,SAAb,C;AAaZ,MAAMoB,IAAN,CAAW;AAGhBF,cAAYC,IAAZ,EAA0BE,MAA1B,EAAyC;AACvC,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKE,MAAL,GAAcA,MAAd;AACD;AACDC,QAAc;AACZ,QAAI,EAACH,IAAD,EAAOE,MAAP,KAAiB,IAArB;AACA,WAAOA,SAASA,OAAOE,IAAP,CAAYJ,IAAZ,CAAT,GAA6BA,IAApC;AACD;AACDI,OAAKJ,IAAL,EAA2B;AACzB,WAAO,KAAKG,GAAL,iBAAuBH,IAA9B;AACD;AAbe;;QAALC,I,GAAAA,I;AAuBN,UAAUvB,QAAV,CAAmB2B,IAAnB,EAA+C;AACpD,QAAMA,IAAN;AACA,OAAK,IAAIC,KAAT,IAAkBD,KAAKE,QAAvB,EAAiC;AAC/B,WAAO7B,SAAS4B,KAAT,CAAP;AACD;AACF;;AAED,SAASE,KAAT,CAAeC,IAAf,EAAgD;AAC9C,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtChC,OAAG4B,KAAH,CAASC,IAAT,EAAe,CAACI,GAAD,EAAM9B,IAAN,KAAe;AAC5B8B,YAAMD,OAAOC,GAAP,CAAN,GAAoBF,QAAQ5B,IAAR,CAApB;AACD,KAFD;AAGD,GAJM,CAAP;AAKD;;AAED,SAAS+B,OAAT,CAAiBL,IAAjB,EAAkD;AAChD,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtChC,OAAGkC,OAAH,CAAWL,IAAX,EAAiB,CAACI,GAAD,EAAME,KAAN,KAAgB;AAC/BF,YAAMD,OAAOC,GAAP,CAAN,GAAoBF,QAAQI,KAAR,CAApB;AACD,KAFD;AAGD,GAJM,CAAP;AAKD;;AAED,eAAeC,UAAf,CAA0BP,IAA1B,EAAqD;AACnD,MAAIQ,UAAUR,KAAKN,GAAL,EAAd;AACA,MAAIpB,OAAO,MAAMyB,MAAMS,OAAN,CAAjB;AACA,MAAIC,OAAOrC,SAASC,MAAT,CAAgBC,IAAhB,CAAX;AACA,SAAO;AACL0B,QADK;AAELS,QAFK;AAGLC,UAAMD,SAASrC,SAASI,IAAlB,GAAyBF,KAAKoC,IAA9B,GAAqC,CAHtC;AAILZ,cAAUW,SAASrC,SAASM,SAAlB,GAA8B,MAAMuB,QAAQU,GAAR,CAAY,CACtD,MAAMN,QAAQG,OAAR,CADgD,EAExDI,GAFwD,CAEpDrB,QAAQgB,WAAW,IAAIf,IAAJ,CAASD,IAAT,EAAeS,IAAf,CAAX,CAF4C,CAAZ,CAApC,GAEyC;AAN9C,GAAP;AAQD;;AAEM,eAAe9B,IAAf,CAAoB2C,KAApB,EAAoD;AACzD,MAAIH,OAAO,CAAX;AACA,MAAII,QAAQ,CAAZ;AACA,MAAIC,QAAQ,EAAZ;AACA,OAAK,IAAIf,IAAT,IAAiBa,KAAjB,EAAwB;AACtB,UAAM,mBAAS,YAAWb,KAAKN,GAAL,EAAW,EAA/B,CAAN;AACA,QAAIsB,OAAO,MAAMT,WAAWP,IAAX,CAAjB;AACA,SAAK,IAAIJ,IAAT,IAAiB3B,SAAS+C,IAAT,CAAjB,EAAiC;AAC/BF;AACAJ,cAAQd,KAAKc,IAAb;AACD;AACDK,UAAME,IAAN,CAAWD,IAAX;AACD;AACD,QAAM,mBAAS,SAAQF,KAAM,WAAU,uBAAYJ,IAAZ,CAAkB,EAAnD,CAAN;AACA,SAAOK,KAAP;AACD","file":"scanning.js","sourcesContent":["// @flow\nimport * as fs from 'fs';\nimport {sep as DIR_SEP} from 'path';\nimport {formatBytes, printLn} from './util';\n\nexport class FileType {\n  static create(stat: fs.Stats): FileType {\n    if (stat.isFile()) return FileType.File;\n    if (stat.isDirectory()) return FileType.Directory;\n    if (stat.isSymbolicLink()) return FileType.Symlink;\n    if (stat.isBlockDevice()) return FileType.BlockDev;\n    if (stat.isCharacterDevice()) return FileType.CharDev;\n    if (stat.isFIFO()) return FileType.FIFO;\n    if (stat.isSocket()) return FileType.Socket;\n    return FileType.Unknown;\n  }\n\n  static File = new FileType('file');\n  static Directory = new FileType('dir');\n  static Symlink = new FileType('link');\n  static BlockDev = new FileType('block');\n  static CharDev = new FileType('char');\n  static FIFO = new FileType('pipe');\n  static Socket = new FileType('socket');\n  static Unknown = new FileType('unknown');\n\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n/**\n * To save on memory for large trees, nodes with parents only contain the\n * basename of their path as `name`. A full path can be made by following\n * the parents. Nodes without parents have a full path as `name`.\n */\nexport class Path {\n  name: string;\n  parent: ?Path;\n  constructor(name: string, parent?: Path) {\n    this.name = name;\n    this.parent = parent;\n  }\n  get(): string {\n    let {name, parent} = this;\n    return parent ? parent.join(name) : name;\n  }\n  join(name: string): string {\n    return this.get() + DIR_SEP + name;\n  }\n}\n\nexport interface Node {\n  +type: FileType;\n  +path: Path;\n  +size: number;\n  +children: $ReadOnlyArray<Node>;\n}\n\nexport function* traverse(node: Node): Iterable<Node> {\n  yield node;\n  for (let child of node.children) {\n    yield* traverse(child);\n  }\n}\n\nfunction lstat(path: string): Promise<fs.Stats> {\n  return new Promise((resolve, reject) => {\n    fs.lstat(path, (err, stat) => {\n      err ? reject(err) : resolve(stat);\n    });\n  });\n}\n\nfunction readdir(path: string): Promise<string[]> {\n  return new Promise((resolve, reject) => {\n    fs.readdir(path, (err, names) => {\n      err ? reject(err) : resolve(names);\n    });\n  });\n}\n\nasync function createNode(path: Path): Promise<Node> {\n  let pathStr = path.get();\n  let stat = await lstat(pathStr);\n  let type = FileType.create(stat);\n  return {\n    path,\n    type,\n    size: type === FileType.File ? stat.size : 0,\n    children: type === FileType.Directory ? await Promise.all((\n        await readdir(pathStr)\n    ).map(name => createNode(new Path(name, path)))) : [],\n  };\n}\n\nexport async function scan(paths: Path[]): Promise<Node[]> {\n  let size = 0;\n  let count = 0;\n  let roots = [];\n  for (let path of paths) {\n    await printLn(`Scanning ${path.get()}`);\n    let root = await createNode(path);\n    for (let node of traverse(root)) {\n      count++;\n      size += node.size;\n    }\n    roots.push(root);\n  }\n  await printLn(`Found ${count} files, ${formatBytes(size)}`);\n  return roots;\n}\n"]}