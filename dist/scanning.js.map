{"version":3,"sources":["../src/scanning.js"],"names":["scan","fs","FileType","create","stat","isFile","File","isDirectory","Directory","isSymbolicLink","Symlink","isBlockDevice","BlockDev","isCharacterDevice","CharDev","isFIFO","FIFO","isSocket","Socket","Unknown","constructor","name","cid","Path","parent","get","join","createNode","path","lstat","type","size","children","Promise","all","readdir","map","paths","count","roots","visit","node","forEach","root","push"],"mappings":"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","file":"scanning.js","sourcesContent":["// @flow\nimport * as fs from './promise_fs';\nimport {sep as DIR_SEP} from 'path';\nimport {formatBytes, printLn, newCid, formatNumber} from './util';\n\nexport class FileType {\n  static create(stat: fs.Stats): FileType {\n    if (stat.isFile()) return FileType.File;\n    if (stat.isDirectory()) return FileType.Directory;\n    if (stat.isSymbolicLink()) return FileType.Symlink;\n    if (stat.isBlockDevice()) return FileType.BlockDev;\n    if (stat.isCharacterDevice()) return FileType.CharDev;\n    if (stat.isFIFO()) return FileType.FIFO;\n    if (stat.isSocket()) return FileType.Socket;\n    return FileType.Unknown;\n  }\n\n  static File: FileType = new FileType('file');\n  static Directory: FileType = new FileType('dir');\n  static Symlink: FileType = new FileType('link');\n  static BlockDev: FileType = new FileType('block');\n  static CharDev: FileType = new FileType('char');\n  static FIFO: FileType = new FileType('pipe');\n  static Socket: FileType = new FileType('socket');\n  static Unknown: FileType = new FileType('unknown');\n\n  name: string;\n  cid: number;\n  constructor(name: string) {\n    this.cid = newCid();\n    this.name = name;\n  }\n}\n\n/**\n * To save on memory for large trees, nodes with parents only contain the\n * basename of their path as `name`. A full path can be made by following\n * the parents. Nodes without parents have a full path as `name`.\n */\nexport class Path {\n  name: string;\n  parent: Path | null;\n  constructor(name: string, parent: Path | null = null) {\n    this.name = name;\n    this.parent = parent;\n  }\n  get(): string {\n    let {name, parent} = this;\n    return parent ? parent.join(name) : name;\n  }\n  join(name: string): string {\n    return this.get() + DIR_SEP + name;\n  }\n}\n\nexport interface Node {\n  +type: FileType;\n  +path: Path;\n  +size: number;\n  +children: $ReadOnlyArray<Node>;\n}\n\nasync function createNode(path: Path): Promise<Node> {\n  let stat = await fs.lstat(path.get());\n  let type = FileType.create(stat);\n  let size = type === FileType.File ? stat.size : 0;\n  let children;\n  if (type === FileType.Directory) {\n    children = await Promise.all(\n      (await fs.readdir(path.get())).map(name =>\n        createNode(new Path(name, path)),\n      ),\n    );\n  } else {\n    children = [];\n  }\n  return {path, type, size, children};\n}\n\nexport async function scan(paths: Path[]): Promise<Node[]> {\n  let size = 0;\n  let count = 0;\n  let roots = [];\n  function visit(node) {\n    count++;\n    size += node.size;\n    node.children.forEach(visit);\n  }\n  for (let path of paths) {\n    await printLn(`Scanning ${path.get()}`);\n    let root = await createNode(path);\n    visit(root);\n    roots.push(root);\n  }\n  await printLn(`Found ${formatNumber(count, 0)} files, ${formatBytes(size)}`);\n  return roots;\n}\n"]}