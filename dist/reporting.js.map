{"version":3,"sources":["../src/reporting.js"],"names":["report","readline","fs","roots","groups","gatherDuplicates","count","length","bytes","group","amountDuplicated","runReport","nodes","deepSize","node","size","node2","children","getDuplicateCids","one","Set","many","forEach","visit","cid","has","add","dups","map","Map","list","get","undefined","set","push","Array","from","values","filter","x","sort","a","b","rl","Readline","index","quit","info","type","name","choose","path","i","key","action","j","removeRecursive","splice","concat","close","constructor","createInterface","input","process","stdin","output","stdout","options","question","response","Promise","resolve","answer","trim","child","Directory","rmdir","unlink"],"mappings":"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","file":"reporting.js","sourcesContent":["// @flow\n\nimport type {CompleteNode} from './reading';\nimport {formatBytes, formatNumber, printLn, sum} from './util';\nimport * as readline from 'readline';\nimport * as fs from './promise_fs';\nimport {FileType, Node} from './scanning';\n\nexport async function report(roots: CompleteNode[]): Promise<void> {\n  let groups = gatherDuplicates(roots);\n  let count = formatNumber(groups.length);\n  let bytes = formatBytes(sum(groups, group => amountDuplicated(group)));\n  await printLn();\n  await printLn(`Found ${count} duplicate sets, ${bytes} duplicated`);\n  await runReport(groups);\n}\n\nfunction amountDuplicated(nodes: CompleteNode[]): number {\n  if (nodes.length === 0) return 0;\n  return deepSize(nodes[0]) * (nodes.length - 1);\n}\n\nfunction deepSize(node: CompleteNode): number {\n  let {size} = node;\n  for (let node2 of node.children) {\n    size += deepSize(node2);\n  }\n  return size;\n}\n\nfunction getDuplicateCids(roots: CompleteNode[]): Set<number> {\n  let one = new Set();\n  let many = new Set();\n  roots.forEach(function visit({cid, children}) {\n    if (one.has(cid)) {\n      many.add(cid);\n    } else {\n      one.add(cid);\n    }\n    children.forEach(visit);\n  });\n  return many;\n}\n\nfunction gatherDuplicates(roots: CompleteNode[]): CompleteNode[][] {\n  let dups = getDuplicateCids(roots);\n  let map = new Map();\n  roots.forEach(function visit(node: CompleteNode): void {\n    let {cid} = node;\n    if (!dups.has(cid)) {\n      node.children.forEach(visit);\n    } else {\n      let list = map.get(cid);\n      if (list === undefined) {\n        map.set(cid, [node]);\n      } else {\n        list.push(node);\n      }\n    }\n  });\n  return Array.from(map.values()).filter(x => x.length > 1);\n}\n\nasync function runReport(groups: CompleteNode[][]): Promise<void> {\n  groups.sort((a, b) => amountDuplicated(b) - amountDuplicated(a));\n\n  let rl = new Readline();\n  let index = 0;\n  let quit = false;\n  while (groups.length > 0 && !quit) {\n    index = (index + groups.length) % groups.length;\n    let group = groups[index];\n    let count = group.length;\n    let bytes = formatBytes(amountDuplicated(group));\n    let info = group[0].type.name + ' ' + group[0].cid;\n\n    await printLn();\n    await printLn(\n      `${index +\n        1}/${groups.length}: ${info} (${count} copies, ${bytes} duplicated)`,\n    );\n\n    await rl.choose(\n      group\n        .map(({path}, i) => ({\n          key: `${i + 1}`,\n          name: `Keep only \"${path.get()}\"`,\n          async action() {\n            let j = 0;\n            for (let node of group) {\n              if (i !== j) {\n                await removeRecursive(node);\n              }\n              j++;\n            }\n            // Delete the group\n            groups.splice(index, 1);\n          },\n        }))\n        .concat([\n          {\n            key: 'D',\n            name: 'Delete ALL',\n            async action() {\n              for (let node of group) {\n                await removeRecursive(node);\n              }\n              // Delete the group\n              groups.splice(index, 1);\n            },\n          },\n          {\n            key: 'n',\n            name: 'Next duplicate',\n            async action() {\n              index++;\n            },\n          },\n          {\n            key: 'p',\n            name: 'Previous duplicate',\n            async action() {\n              index--;\n            },\n          },\n          {\n            key: 'q',\n            name: 'Quit',\n            async action() {\n              quit = true;\n            },\n          },\n        ]),\n    );\n  }\n  rl.close();\n  await printLn();\n  if (quit) {\n    await printLn('Quit');\n  } else {\n    await printLn('DONE');\n  }\n}\n\ninterface ReadlineAction {\n  +key: string;\n  +name: string;\n  +action: () => Promise<void>;\n}\n\nclass Readline {\n  rl: readline.Interface;\n  constructor() {\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n  }\n  close(): void {\n    this.rl.close();\n  }\n  async choose(options: ReadlineAction[]): Promise<void> {\n    while (true) {\n      let question = 'Please select an option:\\n';\n      for (let {key, name} of options) {\n        question += `  ${key}: ${name}\\n`;\n      }\n      question += '> ';\n      let response = await new Promise(resolve => {\n        this.rl.question(question, answer => {\n          resolve(answer);\n        });\n      });\n      response = response.trim();\n      for (let {key, action} of options) {\n        if (key === response) {\n          await action();\n          return;\n        }\n      }\n    }\n  }\n}\n\nasync function removeRecursive(node: Node): Promise<void> {\n  // It is important that we use the original file tree to do the removal.\n  // This way if a new file has been added to the directory, we get a ENOENT\n  // and we don't accidentally remove more than we expected to.\n  // This doesn't verify that files haven't changed before we remove them,\n  // though.\n  for (let child of node.children) {\n    await removeRecursive(child);\n  }\n  let path = node.path.get();\n  if (node.type === FileType.Directory) {\n    await printLn('rmdir ' + path);\n    await fs.rmdir(path);\n  } else {\n    await printLn('unlink ' + path);\n    await fs.unlink(path);\n  }\n}\n"]}