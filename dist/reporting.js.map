{"version":3,"sources":["../src/reporting.js"],"names":["report","readline","fs","roots","groups","gatherDuplicates","count","length","bytes","group","amountDuplicated","runReport","nodes","deepSize","node","size","node2","getDuplicateCids","one","Set","many","root","cid","has","add","dups","map","Map","child","children","list","get","undefined","set","push","Array","from","values","filter","x","sort","a","b","rl","Readline","index","quit","info","type","name","options","i","path","action","j","path2","removeRecursive","splice","choose","close","constructor","createInterface","input","process","stdin","output","stdout","question","key","response","Promise","resolve","answer","trim","option","stat","lstat","isDirectory","readdir","rmdir","unlink"],"mappings":"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","file":"reporting.js","sourcesContent":["// @flow\n\nimport type {CompleteNode} from './reading';\nimport {traverse} from './reading';\nimport {formatBytes, formatNumber, printLn, sum} from './util';\nimport * as readline from 'readline';\nimport * as fs from './promise_fs';\nimport {sep as DIR_SEP} from 'path';\n\nexport async function report(roots: CompleteNode[]): Promise<void> {\n  let groups = gatherDuplicates(roots);\n  let count = formatNumber(groups.length);\n  let bytes = formatBytes(sum(groups, group => amountDuplicated(group)));\n  await printLn();\n  await printLn(`Found ${count} duplicate sets, ${bytes} duplicated`);\n  await runReport(groups);\n}\n\nfunction amountDuplicated(nodes: CompleteNode[]): number {\n  if (nodes.length === 0) return 0;\n  return deepSize(nodes[0]) * (nodes.length - 1);\n}\n\nfunction deepSize(node: CompleteNode): number {\n  let size = 0;\n  for (let node2 of traverse(node)) {\n    size += node2.size;\n  }\n  return size;\n}\n\nfunction getDuplicateCids(roots: CompleteNode[]): Set<number> {\n  let one = new Set();\n  let many = new Set();\n  for (let root of roots) {\n    for (let node of traverse(root)) {\n      let {cid} = node;\n      if (one.has(cid)) {\n        many.add(cid);\n      } else {\n        one.add(cid);\n      }\n    }\n  }\n  return many;\n}\n\nfunction gatherDuplicates(roots: CompleteNode[]): CompleteNode[][] {\n  let dups = getDuplicateCids(roots);\n  let map = new Map();\n  function add(node: CompleteNode): void {\n    let {cid} = node;\n    if (!dups.has(cid)) {\n      for (let child of node.children) {\n        add(child);\n      }\n    } else {\n      let list = map.get(cid);\n      if (list === undefined) {\n        list = [];\n        map.set(cid, list);\n      }\n      list.push(node);\n    }\n  }\n  for (let root of roots) {\n    add(root);\n  }\n  return Array.from(map.values()).filter(x => x.length > 1);\n}\n\nasync function runReport(groups: CompleteNode[][]): Promise<void> {\n  groups.sort((a, b) => amountDuplicated(b) - amountDuplicated(a));\n\n  let rl = new Readline();\n  let index = 0;\n  let quit = false;\n  while (groups.length > 0 && !quit) {\n    index = (index + groups.length) % groups.length;\n    let group = groups[index];\n    let count = group.length;\n    let bytes = formatBytes(amountDuplicated(group));\n    let info = group[0].type.name + ' ' + group[0].cid;\n\n    await printLn();\n    await printLn(\n      `${index +\n        1}/${groups.length}: ${info} (${count} copies, ${bytes} duplicated)`,\n    );\n\n    let options = new Map();\n    for (let i = 0; i < group.length; i++) {\n      let {path} = group[i];\n      options.set(`${i + 1}`, {\n        name: `Keep only \"${path.get()}\"`,\n        async action() {\n          for (let j = 0; j < group.length; j++) {\n            let {path: path2} = group[j];\n            if (i !== j) {\n              await removeRecursive(path2.get());\n            }\n          }\n          // Delete the group\n          groups.splice(index, 1);\n        },\n      });\n    }\n    options.set('D', {\n      name: 'Delete ALL',\n      async action() {\n        for (let {path} of group) {\n          await removeRecursive(path.get());\n        }\n        // Delete the group\n        groups.splice(index, 1);\n      },\n    });\n    options.set('n', {\n      name: 'Next duplicate',\n      async action() {\n        index++;\n      },\n    });\n    options.set('p', {\n      name: 'Previous duplicate',\n      async action() {\n        index--;\n      },\n    });\n    options.set('q', {\n      name: 'Quit',\n      async action() {\n        quit = true;\n      },\n    });\n    await rl.choose(options);\n  }\n  rl.close();\n  await printLn();\n  if (quit) {\n    await printLn('Quit');\n  } else {\n    await printLn('DONE');\n  }\n}\n\ninterface ReadlineAction {\n  +name: string;\n  +action: () => Promise<void>;\n}\n\nclass Readline {\n  rl: readline.Interface;\n  constructor() {\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n  }\n  close(): void {\n    this.rl.close();\n  }\n  async choose(options: Map<string, ReadlineAction>): Promise<void> {\n    while (true) {\n      let question = 'Please select an option:\\n';\n      for (let [key, {name}] of options) {\n        question += `  ${key}: ${name}\\n`;\n      }\n      question += '> ';\n      let response = await new Promise(resolve => {\n        this.rl.question(question, answer => {\n          resolve(answer);\n        });\n      });\n      response = response.trim();\n      let option = options.get(response);\n      if (option !== undefined) {\n        await option.action();\n        return;\n      }\n    }\n  }\n}\n\nasync function removeRecursive(path: string): Promise<void> {\n  let stat = await fs.lstat(path);\n  if (stat.isDirectory()) {\n    for (let name of await fs.readdir(path)) {\n      await removeRecursive(path + DIR_SEP + name);\n    }\n    await printLn('rmdir ' + path);\n    await fs.rmdir(path);\n  } else {\n    await printLn('unlink ' + path);\n    await fs.unlink(path);\n  }\n}\n"]}